export const enum TokenSyntactic {
  // Text: &
  Ampersand = "\u0026",
  // Text: &&
  AmpersandAmpersand = "\u0026\u0026",
  // Text: ->
  Arrow = "\u002D\u003E",
  // Text: @
  At = "\u0040",
  // Text: /
  Slash = "\u002F",
  // Text: !
  Exclamation = "\u0021",
  // Text: [
  LeftBracket = "\u005B",
  // Text: ]
  RightBracket = "\u005D",
  // Text: {
  LeftBrace = "\u007B",
  // Text: }
  RightBrace = "\u007D",
  // Text: :
  Colon = "\u003A",
  // Text: ,
  Comma = "\u002C",
  // Text: =
  Equal = "\u003D",
  // Text: ==
  EqualEqual = "\u003D\u003D",
  // Text: !=
  ExclamationEqual = "\u0021\u003D",
  // Text: >
  // also _greater_than for template disambiguation
  GreaterThan = "\u003E",
  // Text: >=
  // also _greater_than_equal for template disambiguation
  GreaterThanEqual = "\u003E\u003D",
  // Text: >>
  // also _shift_right for template disambiguation
  ShiftRight = "\u003E\u003E",
  // Text: <
  // also _less_than for template disambiguation
  LessThan = "\u003C",
  // Text: <=
  // also _less_than_equal for template disambiguation
  LessThanEqual = "\u003C\u003D",
  // Text: <<
  // also _shift_left for template disambiguation
  ShiftLeft = "\u003C\u003C",
  // Text: %
  Percent = "\u0025",
  // Text: -
  Dash = "\u002D",
  // Text: --
  DashDash = "\u002D\u002D",
  // Text: .
  Dot = "\u002E",
  // Text: +
  Plus = "\u002B",
  // Text: ++
  PlusPlus = "\u002B\u002B",
  // Text: |
  Pipe = "\u007C",
  // Text: ||
  PipePipe = "\u007C\u007C",
  // Text: (
  LeftParenthesis = "\u0028",
  // Text: )
  RightParenthesis = "\u0029",
  // Text: ;
  Semicolon = "\u003B",
  // Text: *
  Asterisk = "\u002A",
  // Text: ~
  Underscore = "\u005F",
  // Text: ^
  Caret = "\u005E",
  // Text: +=
  PlusEqual = "\u002B\u003D",
  // Text: -=
  DashEqual = "\u002D\u003D",
  // Text: *=
  AsteriskEqual = "\u002A\u003D",
  // Text: /=
  SlashEqual = "\u002F\u003D",
  // Text: %=
  PercentEqual = "\u0025\u003D",
  // Text: &=
  AmpersandEqual = "\u0026\u003D",
  // Text: |=
  PipeEqual = "\u007C\u003D",
  // Text: ^=
  CaretEqual = "\u005E\u003D",
  // Text: >>=
  // also _shift_right_assign for template disambiguation
  ShiftRightEqual = "\u003E\u003E\u003D",
  // Text: <<=
  // also _shift_left_assign for template disambiguation
  ShiftLeftEqual = "\u003C\u003C\u003D",
  /*
  Text: >
  This token is textually the same as the greater_than syntactic token.
  It is generated by template list disambiguation, and is used as the last token in a template list.
 */
  TemplateArgsEnd = "\u003E",
  /*
  Text: <
  This token is textually the same as the less_than syntactic token.
  It is generated by template list disambiguation, and is used as the first token in a template list.
 */
  TemplateArgsStart = "\u003C",
  /*
  Text: <
  This token informs parser to scan for template lists.
  It triggers template list disambiguation.
 */
  DisambiguateTemplate = "\u003C",
}

export const enum TokenX {}

export const enum TokenX {}

export const enum TokenX {}

export const enum TokenX {}

export const enum TokenX {}

export const enum TokenX {}

export type WGSLSource = string;

export function isToken(source: WGSLSource, start: number, pattern: string): boolean {
  for (let i = 0; i < pattern.length; ++i) {
    if (source[start + i] !== pattern[i]) {
      return false;
    }
  }

  return true;
}
export function isSomeToken(source: WGSLSource, start: number, patterns: string[]): boolean {
  for (const pattern of patterns) {
    if (isToken(source, start, pattern)) {
      return true;
    }
  }

  return false;
}

export function isProgramEnd(source: WGSLSource, index: number): boolean {
  return index === source.length;
}

export function removeSourceFromTo(source: WGSLSource, from: number, to: number): WGSLSource {
  return source.substring(0, from) + source.substring(to);
}
