export const enum TokenSyntactic {
  // Text: &
  Ampersand = "\u0026",
  // Text: &&
  AmpersandAmpersand = "\u0026\u0026",
  // Text: ->
  Arrow = "\u002D\u003E",
  // Text: @
  At = "\u0040",
  // Text: /
  Slash = "\u002F",
  // Text: !
  Exclamation = "\u0021",
  // Text: [
  LeftBracket = "\u005B",
  // Text: ]
  RightBracket = "\u005D",
  // Text: {
  LeftBrace = "\u007B",
  // Text: }
  RightBrace = "\u007D",
  // Text: :
  Colon = "\u003A",
  // Text: ,
  Comma = "\u002C",
  // Text: =
  Equal = "\u003D",
  // Text: ==
  DoubleEqual = "\u003D\u003D",
  // Text: !=
  ExclamationEqual = "\u0021\u003D",
  // Text: >
  // also _greater_than for template disambiguation
  GreaterThan = "\u003E",
  // Text: >=
  // also _greater_than_equal for template disambiguation
  GreaterThanEqual = "\u003E\u003D",
  // Text: >>
  // also _shift_right for template disambiguation
  ShiftRight = "\u003E\u003E",
  // Text: <
  // also _less_than for template disambiguation
  LessThan = "\u003C",
  // Text: <=
  // also _less_than_equal for template disambiguation
  LessThanEqual = "\u003C\u003D",
  // Text: <<
  // also _shift_left for template disambiguation
  ShiftLeft = "\u003C\u003C",
  // Text: %
  Percent = "\u0025",
  // Text: -
  Dash = "\u002D",
  // Text: --
  DashDash = "\u002D\u002D",
  // Text: .
  Dot = "\u002E",
  // Text: +
  Plus = "\u002B",
  // Text: ++
  PlusPlus = "\u002B\u002B",
  // Text: |
  Pipe = "\u007C",
  // Text: ||
  PipePipe = "\u007C\u007C",
  // Text: (
  LeftParenthesis = "\u0028",
  // Text: )
  RightParenthesis = "\u0029",
  // Text: ;
  Semicolon = "\u003B",
  // Text: *
  Asterisk = "\u002A",
  // Text: ~
  Underscore = "\u005F",
  // Text: ^
  Caret = "\u005E",
  // Text: +=
  PlusEqual = "\u002B\u003D",
  // Text: -=
  DashEqual = "\u002D\u003D",
  // Text: *=
  AsteriskEqual = "\u002A\u003D",
  // Text: /=
  SlashEqual = "\u002F\u003D",
  // Text: %=
  PercentEqual = "\u0025\u003D",
  // Text: &=
  AmpersandEqual = "\u0026\u003D",
  // Text: |=
  PipeEqual = "\u007C\u003D",
  // Text: ^=
  CaretEqual = "\u005E\u003D",
  // Text: >>=
  // also _shift_right_assign for template disambiguation
  ShiftRightEqual = "\u003E\u003E\u003D",
  // Text: <<=
  // also _shift_left_assign for template disambiguation
  ShiftLeftEqual = "\u003C\u003C\u003D",
  /*
  Text: >
  This token is textually the same as the greater_than syntactic token.
  It is generated by template list disambiguation, and is used as the last token in a template list.
 */
  TemplateArgsEnd = "\u003E",
  /*
  Text: <
  This token is textually the same as the less_than syntactic token.
  It is generated by template list disambiguation, and is used as the first token in a template list.
 */
  TemplateArgsStart = "\u003C",
  /*
  Text: <
  This token informs parser to scan for template lists.
  It triggers template list disambiguation.
 */
  DisambiguateTemplate = "\u003C",
}

export type WGSLSource = string;

export interface WebgpuSource {
  vertex?: {
    entry: string;
  };
  fragment?: {
    entry: string;
  };
  compute?: {
    entry: string;
  };
  source: string;
}

/*
1. Remove comments:
  - Replace the first comment with a space code point (U+0020).
  - Repeat until no comments remain.
2. Find template lists, using the algorithm in § 3.9 Template Lists.
3. Parse the whole text, attempting to match the translation_unit grammar rule.
   Parsing uses a LALR(1) parser (one token of lookahead) [DeRemer1969],
   with the following customization:
    - Tokenization is interleaved with parsing, and is context-aware. When the parser requests the next token:
      - Consume and ignore an initial sequence of blankspace code points.
      - If the next code point is the start of a template list, consume it and return _template_args_start.
      - If the next code point is the end of a template list, consume it and return _template_args_end.
      - Otherwise:
        - A token candidate is any WGSL token formed from the non-empty prefix of the remaining unconsumed code points.
        - The token returned is the longest token candidate that is also a valid lookahead token for the current parser state. [VanWyk2007]
*/

/*
A comment is a span of text that does not influence the validity or meaning of a WGSL program, except that a comment can separate tokens. Shader authors can use comments to document their programs.
- A line-ending comment is a kind of comment consisting of the two code points // (U+002F followed by U+002F) and the code points that follow, up until but not including:
  - the next line break, or
  - the end of the program.
- A block comment is a kind of comment consisting of:
  - The two code points /* (U+002F followed by U+002A)
  - Then any sequence of:
    - A block comment, or
    - Text that does not contain either *\/ (U+002A followed by U+002F) or /* (U+002F followed by U+002A)
  - Then the two code points *\/ (U+002A followed by U+002F)
*/

/**
 * A blankspace is a contiguous sequence of code points that are not line breaks.
 * @see https://www.w3.org/TR/WGSL/#blankspace
 */
export const enum TokenBlankspace {
  // Text: " "
  Space = "\u0020",
  // Text: "\t"
  HorizontalTab = "\u0009",
  // Text: "\n"
  LineFeed = "\u000A",
  // Text: "\v"
  VerticalTab = "\u000B",
  // Text: "\f"
  FormFeed = "\u000C",
  // Text: "\r"
  CarriageReturn = "\u000D",
  // Text: none
  NextLine = "\u0085",
  // Text: none
  LeftToRightMark = "\u200E",
  // Text: none
  RightToLeftMark = "\u200F",
  // Text: none
  LineSeparator = "\u2028",
  // Text: none
  ParagraphSeparator = "\u2029",
}
const blackspaces = [
  TokenBlankspace.Space,
  TokenBlankspace.HorizontalTab,
  TokenBlankspace.LineFeed,
  TokenBlankspace.VerticalTab,
  TokenBlankspace.FormFeed,
  TokenBlankspace.CarriageReturn,
  TokenBlankspace.NextLine,
  TokenBlankspace.LeftToRightMark,
  TokenBlankspace.RightToLeftMark,
  TokenBlankspace.LineSeparator,
  TokenBlankspace.ParagraphSeparator,
];

/**
 * A line break is a contiguous sequence of blankspace code points indicating the end of a line.
 * @see https://www.w3.org/TR/WGSL/#line-break
 */
export const enum TokenLineBreak {
  // Text: "\n"
  LineFeed = "\u000A",
  // Text: "\v"
  VerticalTab = "\u000B",
  // Text: "\f"
  FormFeed = "\u000C",
  // Text: "\r"
  CarriageReturn = "\u000D",
  // Text: "\r\n"
  CarriageReturnLineFeed = "\u000D\u000A",
  // Text: none
  NextLine = "\u0085",
  // Text: none
  LineSeparator = "\u2028",
  // Text: none
  ParagraphSeparator = "\u2029",
}

const linebreaks = [
  TokenLineBreak.LineFeed,
  TokenLineBreak.VerticalTab,
  TokenLineBreak.FormFeed,
  TokenLineBreak.CarriageReturn,
  TokenLineBreak.CarriageReturnLineFeed,
  TokenLineBreak.NextLine,
  TokenLineBreak.LineSeparator,
  TokenLineBreak.ParagraphSeparator,
];

export function isToken(source: WGSLSource, start: number, pattern: string): boolean {
  for (let i = 0; i < pattern.length; ++i) {
    if (source[start + i] !== pattern[i]) {
      return false;
    }
  }

  return true;
}

export function isLinebreak(source: WGSLSource, start: number): boolean {
  for (let i = 0; i < linebreaks.length; ++i) {
    if (isToken(source, start, linebreaks[i])) {
      return true;
    }
  }

  return false;
}

export function isBlankspace(source: WGSLSource, start: number): boolean {
  for (let i = 0; i < blackspaces.length; ++i) {
    if (isToken(source, start, blackspaces[i])) {
      return true;
    }
  }

  return false;
}

export function isProgramEnd(source: WGSLSource, index: number): boolean {
  return index === source.length;
}

export function removeSourceFromTo(source: WGSLSource, from: number, to: number): WGSLSource {
  return source.substring(0, from) + source.substring(to);
}
